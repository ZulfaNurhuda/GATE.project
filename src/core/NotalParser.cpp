/**
 * @file NotalParser.cpp
 * @brief Implementation of the NOTAL language parser for the GATE transpiler
 * 
 * This file contains the implementation of the NotalParser class, which is
 * responsible for parsing a stream of tokens into an Abstract Syntax Tree (AST).
 * The parser implements a recursive descent parsing strategy and handles the
 * complete NOTAL language grammar.
 * 
 * The parser processes tokens generated by the NotalLexer and constructs
 * appropriate AST nodes for statements, expressions, and declarations.
 * It includes comprehensive error handling and recovery mechanisms.
 * 
 * @author GATE Project Team
 * @version 1.0
 * @date 2025
 */

#include "core/NotalParser.h"
#include "diagnostics/DiagnosticEngine.h"
#include "core/ErrorRecovery.h"
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>

namespace gate::transpiler {

// Using directives for brevity within the implementation
using gate::core::Token;
using gate::core::TokenType;
using namespace gate::ast;

/**
 * @brief Constructor for NotalParser
 * 
 * Initializes the parser with a vector of tokens to be parsed.
 * Sets up the initial state for parsing.
 * 
 * @param tokens Vector of tokens from the lexer
 */
NotalParser::NotalParser(const std::vector<Token>& tokens, diagnostics::DiagnosticEngine& engine)
    : tokens_(tokens), diagnosticEngine_(engine), current_(0) {}

void NotalParser::reportWarning(const std::string& message, const core::Token& token) {
    diagnostics::SourceLocation loc(token.filename, token.line, token.column, token.lexeme.length());
    auto diag = diagnostics::Diagnostic::Builder(message, loc)
                    .withLevel(diagnostics::DiagnosticLevel::WARNING)
                    .withCategory(diagnostics::DiagnosticCategory::SYNTAX_ERROR)
                    .build();
    diagnosticEngine_.report(diag);
}

// --- Public Parse Method ---

/**
 * @brief Main parsing entry point
 * 
 * This method initiates the parsing process by calling the program()
 * method to parse the top-level program structure. It includes error
 * handling to catch parsing errors and attempt recovery.
 * 
 * @return std::shared_ptr<ProgramStmt> Pointer to the root AST node,
 *         or nullptr if parsing fails
 * 
 * @note Catches ParseError exceptions and attempts to synchronize
 * @note Returns nullptr on parsing failure for graceful error handling
 */
std::shared_ptr<ProgramStmt> NotalParser::parse() {
    try {
        return program();
    } catch (const ParseError& error) {
        return nullptr;
    }
}

// --- Grammar Rule Methods ---

/**
 * @brief Parses the top-level program structure
 * 
 * Implements the grammar rule:
 * program -> 'PROGRAM' IDENTIFIER kamus algoritma subprogram*
 * 
 * @return std::shared_ptr<ProgramStmt> The program AST node
 * @throws ParseError if program structure is invalid
 */
std::shared_ptr<ProgramStmt> NotalParser::program() {
    consume(TokenType::PROGRAM, "Expect 'PROGRAM'.");
    Token name = consume(TokenType::IDENTIFIER, "Expect program name.");
    
    std::shared_ptr<KamusStmt> kamusBlock = kamus();

    std::shared_ptr<AlgoritmaStmt> algoritmaBlock = algoritma();

    std::vector<std::shared_ptr<Statement>> ordered_subprograms;
    while (!isAtEnd()) {
        Token subprogramKeyword = peek();
        if (subprogramKeyword.type != TokenType::PROCEDURE && subprogramKeyword.type != TokenType::FUNCTION) {
            throw error(peek(), "Expect procedure or function implementation after main algorithm.");
        }
        advance();

        Token subprogramName = consume(TokenType::IDENTIFIER, "Expect procedure or function name for implementation.");

        auto it = std::find_if(subprogramDeclarations_.begin(), subprogramDeclarations_.end(),
            [&subprogramName](const std::shared_ptr<Statement>& stmt) {
                if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(stmt)) return proc->name.lexeme == subprogramName.lexeme;
                if (auto func = std::dynamic_pointer_cast<FunctionStmt>(stmt)) return func->name.lexeme == subprogramName.lexeme;
                return false;
            });

        if (it == subprogramDeclarations_.end()) {
            throw error(subprogramName, "Implementation provided for an undeclared subprogram.");
        }

        ordered_subprograms.push_back(*it);
        subprogramImplementation(subprogramKeyword, subprogramName);
    }

    return std::make_shared<ProgramStmt>(name, kamusBlock, algoritmaBlock, ordered_subprograms);
}

/**
 * @brief Parses the KAMUS (dictionary/declarations) section
 * 
 * Implements the grammar rule:
 * kamus -> 'KAMUS' declaration*
 * 
 * @return std::shared_ptr<KamusStmt> The kamus AST node
 * @throws ParseError if kamus structure is invalid
 */
std::shared_ptr<KamusStmt> NotalParser::kamus() {
    consume(TokenType::KAMUS, "Expect 'KAMUS'.");
    int kamusKeywordColumn = previous().column;
    std::vector<std::shared_ptr<Statement>> declarations;
    while (!check(TokenType::ALGORITMA) && !isAtEnd()) {
        if ((peek().type == TokenType::PROCEDURE || peek().type == TokenType::FUNCTION) &&
            peek().column <= kamusKeywordColumn) {
            throw error(peek(), "Procedure or function declaration must be indented within 'KAMUS' block.");
        }
        declarations.push_back(declaration());
    }
    return std::make_shared<KamusStmt>(declarations);
}

/**
 * @brief Parses the ALGORITMA (algorithm/main body) section
 * 
 * Implements the grammar rule:
 * algoritma -> 'ALGORITMA' block
 * 
 * @return std::shared_ptr<AlgoritmaStmt> The algoritma AST node
 * @throws ParseError if algoritma structure is invalid
 */
std::shared_ptr<AlgoritmaStmt> NotalParser::algoritma() {
    consume(TokenType::ALGORITMA, "Expect 'ALGORITMA'.");
    std::vector<std::shared_ptr<Statement>> statements = block();
    auto body = std::make_shared<BlockStmt>(statements);
    return std::make_shared<AlgoritmaStmt>(body);
}

/**
 * @brief Parses various types of declarations
 * 
 * Handles constant, type, variable, and subprogram declarations.
 * 
 * @return std::shared_ptr<Statement> The declaration AST node
 * @throws ParseError if declaration syntax is invalid
 */
std::shared_ptr<Statement> NotalParser::declaration() {
    try {
        if (check(TokenType::PROCEDURE) || check(TokenType::FUNCTION)) {
            return subprogramDeclaration();
        }
        if (match({TokenType::CONSTANT})) {
            return constantDeclaration();
        }
        if (match({TokenType::TYPE})) {
            return typeDeclaration();
        }
        return varDeclaration();
    } catch (ParseError& e) {
        synchronize();
        return nullptr;
    }
}

/**
 * @brief Parses constant declarations
 * 
 * Supports both explicit and inferred typing:
 * - constant name: type = value
 * - constant name = value
 * 
 * @return std::shared_ptr<Statement> The constant declaration AST node
 * @throws ParseError if constant declaration syntax is invalid
 */
std::shared_ptr<Statement> NotalParser::constantDeclaration() {
    Token name = consume(TokenType::IDENTIFIER, "Expect constant name.");
    
    Token type;
     if (match({TokenType::COLON})) {
         // Syntax: constant name: type = value (explicit typing)
         type = advance();
         if (type.type != TokenType::INTEGER && type.type != TokenType::REAL &&
             type.type != TokenType::STRING && type.type != TokenType::BOOLEAN &&
             type.type != TokenType::CHARACTER && type.type != TokenType::NULL_TYPE &&
             type.type != TokenType::NULL_LITERAL && type.type != TokenType::IDENTIFIER) {
                 throw error(type, "Expect a type name.");
         }
         
         // Convert NULL_LITERAL to NULL_TYPE for type declarations
         if (type.type == TokenType::NULL_LITERAL) {
             type.type = TokenType::NULL_TYPE;
         }
         consume(TokenType::EQUAL, "Expect '=' after type.");
     } else {
         // Syntax: constant name = value (type inferred)
         consume(TokenType::EQUAL, "Expect '=' after constant name.");
         type = Token{TokenType::IDENTIFIER, "", /*filename*/"", /*line*/0, /*col*/0}; // Empty type for inference
     }

    std::shared_ptr<Expression> initializer = expression();

    return std::make_shared<ConstDeclStmt>(name, type, initializer);
}

std::shared_ptr<Statement> NotalParser::typeDeclaration() {
    Token name = consume(TokenType::IDENTIFIER, "Expect type name.");
    consume(TokenType::COLON, "Expect ':' after type name.");
    
    if (check(TokenType::LESS)) {
        advance();
        
        std::vector<RecordTypeDeclStmt::Field> fields;
        
        if (!check(TokenType::GREATER)) {
            do {
                Token fieldName = consume(TokenType::IDENTIFIER, "Expect field name.");
                consume(TokenType::COLON, "Expect ':' after field name.");
                Token fieldType = advance();
                
                if (fieldType.type != TokenType::INTEGER && fieldType.type != TokenType::REAL &&
                    fieldType.type != TokenType::STRING && fieldType.type != TokenType::BOOLEAN &&
                    fieldType.type != TokenType::CHARACTER && fieldType.type != TokenType::IDENTIFIER) {
                    throw error(fieldType, "Expect a basic type name or custom type.");
                }
                
                fields.emplace_back(fieldName, fieldType);
            } while (match({TokenType::COMMA}));
        }
        
        consume(TokenType::GREATER, "Expect '>' after record fields.");
        return std::make_shared<RecordTypeDeclStmt>(name, fields);
        
    } else if (check(TokenType::LPAREN)) {
        advance();
        
        std::vector<Token> values;
        
        if (!check(TokenType::RPAREN)) {
            do {
                Token value = consume(TokenType::IDENTIFIER, "Expect enum value name.");
                values.push_back(value);
            } while (match({TokenType::COMMA}));
        }
        
        consume(TokenType::RPAREN, "Expect ')' after enum values.");
        return std::make_shared<EnumTypeDeclStmt>(name, values);
    } else {
        throw error(peek(), "Expect '<' for record type or '(' for enum type.");
    }
}

std::shared_ptr<Statement> NotalParser::varDeclaration() {
    std::vector<Token> names;
    do {
        names.push_back(consume(TokenType::IDENTIFIER, "Expect variable name."));
    } while (match({TokenType::COMMA}));

    consume(TokenType::COLON, "Expect ':' after variable name(s).");

    if (check(TokenType::ARRAY)) {
        return arrayDeclaration(names);
    }

    Token type = advance();
    if (type.type != TokenType::INTEGER && type.type != TokenType::REAL &&
        type.type != TokenType::STRING && type.type != TokenType::BOOLEAN &&
        type.type != TokenType::CHARACTER && type.type != TokenType::IDENTIFIER &&
        type.type != TokenType::POINTER && type.type != TokenType::NULL_TYPE) {
        throw error(type, "Expect a type name.");
    }

    if (type.type == TokenType::POINTER) {
        consume(TokenType::TO, "Expect 'to' after 'pointer'.");
        Token pointedType = advance();
        return std::make_shared<VarDeclStmt>(names, type, pointedType);
    }

    if (match({TokenType::PIPE})) {
        std::shared_ptr<Expression> constraint = expression();
        return std::make_shared<ConstrainedVarDeclStmt>(names, type, constraint);
    }

    return std::make_shared<VarDeclStmt>(names, type);
}

std::shared_ptr<Statement> NotalParser::arrayDeclaration(const std::vector<Token>& names) {
    consume(TokenType::ARRAY, "Expect 'array'.");

    if (check(TokenType::LBRACKET)) {
        std::vector<StaticArrayDeclStmt::Dimension> dimensions;
        do {
            consume(TokenType::LBRACKET, "Expect '[' for array dimension.");
            std::shared_ptr<Expression> start = unary();
            consume(TokenType::DOT_DOT, "Expect '..' between dimension bounds.");
            std::shared_ptr<Expression> end = unary();
            consume(TokenType::RBRACKET, "Expect ']' after array dimension.");
            dimensions.push_back({start, end});
        } while (check(TokenType::LBRACKET));

        consume(TokenType::OF, "Expect 'of' after array dimensions.");
        Token elementType = advance();
        return std::make_shared<StaticArrayDeclStmt>(names, dimensions, elementType);

    } else {
        consume(TokenType::OF, "Expect 'of' after 'array'.");
        int dimensionCount = 1;
        while (match({TokenType::ARRAY})) {
            consume(TokenType::OF, "Expect 'of' after 'array'.");
            dimensionCount++;
        }
        Token elementType = advance();
        return std::make_shared<DynamicArrayDeclStmt>(names, dimensionCount, elementType);
    }
}

std::vector<std::shared_ptr<Statement>> NotalParser::block() {
    int initialIndent = 0;
    if (!isAtEnd()) {
        initialIndent = peek().column;
    }
    return parseBlockByIndentation(initialIndent);
}

std::vector<std::shared_ptr<Statement>> NotalParser::parseBlockByIndentation(int expectedIndentLevel) {
    std::vector<std::shared_ptr<Statement>> statements;
    while (!isAtEnd() && peek().column >= expectedIndentLevel) {
        if (peek().column == expectedIndentLevel &&
            (peek().type == TokenType::PROCEDURE || peek().type == TokenType::FUNCTION)) {
            break;
        }
        if (peek().column < expectedIndentLevel) {
            break;
        }
        statements.push_back(statement());
    }
    return statements;
}

/**
 * @brief Parses various types of statements
 * 
 * Dispatches to appropriate statement parsing methods based on
 * the current token type.
 * 
 * @return std::shared_ptr<Statement> The statement AST node
 * @throws ParseError if statement syntax is invalid
 */
std::shared_ptr<Statement> NotalParser::statement() {
    try {
        if (check(TokenType::IF)) return ifStatement();
        if (check(TokenType::WHILE)) return whileStatement();
        if (match({TokenType::REPEAT})) {
            if (peek().type == TokenType::INTEGER_LITERAL) return repeatNTimesStatement();
            return repeatUntilStatement();
        }
        if (check(TokenType::DEPEND)) return dependOnStatement();
        if (check(TokenType::OUTPUT)) return outputStatement();
        if (check(TokenType::INPUT)) return inputStatement();
        if (check(TokenType::ALLOCATE)) return allocateStatement();
        if (check(TokenType::DEALLOCATE)) return deallocateStatement();
        if (peek().type == TokenType::IDENTIFIER && peekNext().type == TokenType::TRAVERSAL) return traversalStatement();
        if (check(TokenType::ITERATE)) return iterateStopStatement();
        if (match({TokenType::STOP})) return std::make_shared<StopStmt>();
        if (match({TokenType::SKIP})) return std::make_shared<SkipStmt>();
        if (check(TokenType::ARROW)) return returnStatement();

        return expressionStatement();
    } catch (ParseError& e) {
        synchronize();
        return nullptr;
    }
}

std::shared_ptr<Statement> NotalParser::allocateStatement() {
    consume(TokenType::ALLOCATE, "Expect 'allocate'.");
    consume(TokenType::LPAREN, "Expect '(' after 'allocate'.");

    std::shared_ptr<Expression> callee = expression();

    std::vector<std::shared_ptr<Expression>> sizes;
    if (check(TokenType::COMMA)) {
        consume(TokenType::COMMA, "Expect ',' after callee in allocate.");
        do {
            sizes.push_back(expression());
        } while (match({TokenType::COMMA}));
    }

    consume(TokenType::RPAREN, "Expect ')' after allocate arguments.");

    return std::make_shared<AllocateStmt>(callee, sizes);
}

std::shared_ptr<Statement> NotalParser::deallocateStatement() {
    consume(TokenType::DEALLOCATE, "Expect 'deallocate'.");

    int dimension = -1;
    if (match({TokenType::LBRACKET})) {
        if (match({TokenType::INTEGER_LITERAL})) {
            dimension = std::stoi(previous().lexeme);
        } else {
            dimension = 1;
        }
        consume(TokenType::RBRACKET, "Expect ']' after deallocate dimension.");
    }

    consume(TokenType::LPAREN, "Expect '(' after 'deallocate'.");
    std::shared_ptr<Expression> callee = expression();
    consume(TokenType::RPAREN, "Expect ')' after deallocate argument.");

    return std::make_shared<DeallocateStmt>(callee, dimension);
}

std::shared_ptr<Statement> NotalParser::inputStatement() {
    consume(TokenType::INPUT, "Expect 'input'.");
    consume(TokenType::LPAREN, "Expect '(' after 'input'.");

    Token variable_token = consume(TokenType::IDENTIFIER, "Expect variable name.");
    auto variable = std::make_shared<Variable>(variable_token);

    consume(TokenType::RPAREN, "Expect ')' after variable name.");
    return std::make_shared<InputStmt>(variable);
}

std::shared_ptr<Statement> NotalParser::ifStatement() {
    Token ifToken = consume(TokenType::IF, "Expect 'if'.");
    return ifStatementBody(ifToken.column);
}

std::shared_ptr<Statement> NotalParser::ifStatementBody(int parentIndentLevel) {
    auto condition = expression();
    consume(TokenType::THEN, "Expect 'then' after condition.");
    
    int thenBranchIndent = 0;
    if (!isAtEnd()) {
        thenBranchIndent = peek().column;
    }

    std::shared_ptr<BlockStmt> thenBranch;
    if (thenBranchIndent > parentIndentLevel) {
        thenBranch = std::make_shared<BlockStmt>(parseBlockByIndentation(thenBranchIndent));
    } else {
        thenBranch = std::make_shared<BlockStmt>(std::vector<std::shared_ptr<Statement>>{});
    }
    
    std::shared_ptr<Statement> elseBranch = nullptr;

    if (match({TokenType::ELIF})) {
        if (previous().column != parentIndentLevel) {
            throw error(previous(), "'elif' must be at the same indentation level as 'if'.");
        }
        elseBranch = ifStatementBody(parentIndentLevel);
    } else if (match({TokenType::ELSE})) {
        if (previous().column != parentIndentLevel) {
            throw error(previous(), "'else' must be at the same indentation level as 'if'.");
        }
        int elseBranchIndent = 0;
        if (!isAtEnd()) {
            elseBranchIndent = peek().column;
        }

        if (elseBranchIndent > parentIndentLevel) {
            elseBranch = std::make_shared<BlockStmt>(parseBlockByIndentation(elseBranchIndent));
        } else {
            elseBranch = std::make_shared<BlockStmt>(std::vector<std::shared_ptr<Statement>>{});
        }
    }

    auto ifStmt = std::make_shared<IfStmt>(condition, thenBranch, elseBranch);
    if (thenBranch) thenBranch->parent = ifStmt;
    if (elseBranch) elseBranch->parent = ifStmt;

    return ifStmt;
}

std::shared_ptr<Statement> NotalParser::whileStatement() {
    Token whileToken = consume(TokenType::WHILE, "Expect 'while'.");
    std::shared_ptr<Expression> condition = expression();
    consume(TokenType::DO, "Expect 'do' after while condition.");
    
    int whileBodyIndent = 0;
    if (!isAtEnd()) {
        whileBodyIndent = peek().column;
    }
    
    if (whileBodyIndent <= whileToken.column) {
        auto bodyBlock = std::make_shared<BlockStmt>(std::vector<std::shared_ptr<Statement>>{});
        return std::make_shared<WhileStmt>(condition, bodyBlock);
    }

    std::shared_ptr<BlockStmt> bodyBlock = std::make_shared<BlockStmt>(parseBlockByIndentation(whileBodyIndent));

    return std::make_shared<WhileStmt>(condition, bodyBlock);
}

std::shared_ptr<Statement> NotalParser::repeatUntilStatement() {
    Token repeatToken = previous();

    int bodyIndent = 0;
    if (!isAtEnd()) {
        bodyIndent = peek().column;
    }

    if (bodyIndent <= repeatToken.column) {
        throw error(peek(), "The body of a repeat-until loop must be indented.");
    }

    auto body = std::make_shared<BlockStmt>(parseBlockByIndentation(bodyIndent));

    consume(TokenType::UNTIL, "Expect 'until' after repeat block.");

    std::shared_ptr<Expression> condition = expression();

    return std::make_shared<RepeatUntilStmt>(body, condition);
}

std::shared_ptr<Statement> NotalParser::traversalStatement() {
    Token iterator = consume(TokenType::IDENTIFIER, "Expect iterator name.");
    consume(TokenType::TRAVERSAL, "Expect 'traversal'.");
    consume(TokenType::LBRACKET, "Expect '[' after 'traversal'.");
    
    std::shared_ptr<Expression> start = expression();
    consume(TokenType::DOT_DOT, "Expect '..' between start and end values.");
    std::shared_ptr<Expression> end = expression();
    
    std::shared_ptr<Expression> step = nullptr;
    if (match({TokenType::STEP})) {
        step = primary();
    }
    
    consume(TokenType::RBRACKET, "Expect ']' after range.");

    int bodyIndent = 0;
    if (!isAtEnd()) {
        bodyIndent = peek().column;
    }

    if (bodyIndent <= iterator.column) {
        throw error(peek(), "The body of a traversal loop must be indented.");
    }

    auto body = std::make_shared<BlockStmt>(parseBlockByIndentation(bodyIndent));
    
    return std::make_shared<TraversalStmt>(iterator, start, end, step, body);
}

std::shared_ptr<Statement> NotalParser::iterateStopStatement() {
    Token iterateToken = consume(TokenType::ITERATE, "Expect 'iterate'.");

    int bodyIndent = 0;
    if (!isAtEnd()) {
        bodyIndent = peek().column;
    }

    if (bodyIndent <= iterateToken.column) {
        throw error(peek(), "The body of an iterate-stop loop must be indented.");
    }

    auto body = std::make_shared<BlockStmt>(parseBlockByIndentation(bodyIndent));

    consume(TokenType::STOP, "Expect 'stop' after iterate block.");
    consume(TokenType::LPAREN, "Expect '(' after 'stop'.");
    std::shared_ptr<Expression> condition = expression();
    consume(TokenType::RPAREN, "Expect ')' after stop condition.");

    return std::make_shared<IterateStopStmt>(body, condition);
}

std::shared_ptr<Statement> NotalParser::repeatNTimesStatement() {
    Token repeatToken = previous();

    std::shared_ptr<Expression> times = primary();
    consume(TokenType::TIMES, "Expect 'times' after number.");

    int bodyIndent = 0;
    if (!isAtEnd()) {
        bodyIndent = peek().column;
    }

    if (bodyIndent <= repeatToken.column) {
        throw error(peek(), "The body of a repeat N times loop must be indented.");
    }

    auto body = std::make_shared<BlockStmt>(parseBlockByIndentation(bodyIndent));

    return std::make_shared<RepeatNTimesStmt>(times, body);
}

std::shared_ptr<Statement> NotalParser::dependOnStatement() {
    Token dependToken = consume(TokenType::DEPEND, "Expect 'depend'.");
    consume(TokenType::ON, "Expect 'on' after 'depend'.");
    consume(TokenType::LPAREN, "Expect '(' after 'on'.");
    std::vector<std::shared_ptr<Expression>> expressions;
    do {
        expressions.push_back(expression());
    } while (match({TokenType::COMMA}));
    consume(TokenType::RPAREN, "Expect ')' after depend on expression(s).");

    std::vector<DependOnStmt::Case> cases;
    std::shared_ptr<Statement> otherwiseBranch = nullptr;

    int caseIndent = 0;
    if (!isAtEnd()) {
        caseIndent = peek().column;
    }

    if (caseIndent <= dependToken.column) {
        throw error(peek(), "Cases for 'depend on' must be indented.");
    }

    while (!isAtEnd() && peek().column == caseIndent && !check(TokenType::OTHERWISE)) {
        std::vector<std::shared_ptr<Expression>> conditions;
        do {
            conditions.push_back(expression());
        } while (match({TokenType::COMMA}));

        consume(TokenType::COLON, "Expect ':' after case conditions.");

        int bodyIndent = 0;
        if (!isAtEnd()) {
            bodyIndent = peek().column;
        }

        if (bodyIndent <= caseIndent) {
            throw error(peek(), "The body of a case must be indented.");
        }

        auto body = std::make_shared<BlockStmt>(parseBlockByIndentation(bodyIndent));
        cases.emplace_back(conditions, body);
    }

    if (match({TokenType::OTHERWISE})) {
        consume(TokenType::COLON, "Expect ':' after 'otherwise'.");
        int otherwiseIndent = 0;
        if (!isAtEnd()) {
            otherwiseIndent = peek().column;
        }
        if (otherwiseIndent <= dependToken.column) {
            throw error(peek(), "The body of 'otherwise' must be indented.");
        }
        otherwiseBranch = std::make_shared<BlockStmt>(parseBlockByIndentation(otherwiseIndent));
    }

    return std::make_shared<DependOnStmt>(expressions, cases, otherwiseBranch);
}

std::shared_ptr<Statement> NotalParser::outputStatement() {
    consume(TokenType::OUTPUT, "Expect 'output'.");
    consume(TokenType::LPAREN, "Expect '(' after 'output'.");
    
    std::vector<std::shared_ptr<Expression>> expressions;
    if (!check(TokenType::RPAREN)) {
        do {
            expressions.push_back(expression());
        } while (match({TokenType::COMMA}));
    }

    consume(TokenType::RPAREN, "Expect ')' after output arguments.");
    return std::make_shared<OutputStmt>(expressions);
}

std::shared_ptr<Statement> NotalParser::expressionStatement() {
    std::shared_ptr<Expression> expr = expression();
    return std::make_shared<ExpressionStmt>(expr);
}


// --- Subprogram Parsing ---

std::shared_ptr<Statement> NotalParser::subprogramDeclaration() {
    if (check(TokenType::PROCEDURE)) {
        return procedureDeclaration();
    }
    if (check(TokenType::FUNCTION)) {
        return functionDeclaration();
    }
    throw error(peek(), "Expect 'procedure' or 'function'.");
}

std::shared_ptr<Statement> NotalParser::procedureDeclaration() {
    consume(TokenType::PROCEDURE, "Expect 'procedure'.");
    Token name = consume(TokenType::IDENTIFIER, "Expect procedure name.");

    std::vector<Parameter> params = parameterList();

    auto it = std::find_if(subprogramDeclarations_.begin(), subprogramDeclarations_.end(),
        [&name](const std::shared_ptr<Statement>& stmt) {
            if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(stmt)) return proc->name.lexeme == name.lexeme;
            if (auto func = std::dynamic_pointer_cast<FunctionStmt>(stmt)) return func->name.lexeme == name.lexeme;
            return false;
        });

    if (it != subprogramDeclarations_.end()) {
        throw error(name, "Subprogram with this name already declared.");
    }

    auto procStmt = std::make_shared<ProcedureStmt>(name, params, nullptr, nullptr);
    subprogramDeclarations_.push_back(procStmt);

    return procStmt;
}

std::shared_ptr<Statement> NotalParser::functionDeclaration() {
    consume(TokenType::FUNCTION, "Expect 'function'.");
    Token name = consume(TokenType::IDENTIFIER, "Expect function name.");

    std::vector<Parameter> params = parameterList();

    consume(TokenType::ARROW, "Expect '->' for function return type.");
    Token returnType = advance();
    if (returnType.type != TokenType::INTEGER && returnType.type != TokenType::REAL &&
        returnType.type != TokenType::STRING && returnType.type != TokenType::BOOLEAN &&
        returnType.type != TokenType::CHARACTER && returnType.type != TokenType::IDENTIFIER) {
            throw error(returnType, "Expect a valid return type name.");
    }

    auto it = std::find_if(subprogramDeclarations_.begin(), subprogramDeclarations_.end(),
        [&name](const std::shared_ptr<Statement>& stmt) {
            if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(stmt)) return proc->name.lexeme == name.lexeme;
            if (auto func = std::dynamic_pointer_cast<FunctionStmt>(stmt)) return func->name.lexeme == name.lexeme;
            return false;
        });

    if (it != subprogramDeclarations_.end()) {
        throw error(name, "Subprogram with this name already declared.");
    }

    auto funcStmt = std::make_shared<FunctionStmt>(name, params, returnType, nullptr, nullptr);
    subprogramDeclarations_.push_back(funcStmt);

    return funcStmt;
}

std::vector<Parameter> NotalParser::parameterList() {
    consume(TokenType::LPAREN, "Expect '(' after subprogram name.");
    std::vector<Parameter> params;
    if (!check(TokenType::RPAREN)) {
        do {
            ParameterMode mode;

            if (peek().type == TokenType::INPUT) {
                advance();
                if (match({TokenType::DIVIDE})) {
                    consume(TokenType::OUTPUT, "Expect 'output' after '/' for 'input/output' parameter.");
                    mode = ParameterMode::INPUT_OUTPUT;
                } else {
                    mode = ParameterMode::INPUT;
                }
            } else if (peek().type == TokenType::OUTPUT) {
                advance();
                mode = ParameterMode::OUTPUT;
            } else {
                throw error(peek(), "Expect 'input', 'output', or 'input/output' for parameter mode.");
            }

            Token name = consume(TokenType::IDENTIFIER, "Expect parameter name.");
            consume(TokenType::COLON, "Expect ':' after parameter name.");
            Token type = advance();
             if (type.type != TokenType::INTEGER && type.type != TokenType::REAL &&
                type.type != TokenType::STRING && type.type != TokenType::BOOLEAN &&
                type.type != TokenType::CHARACTER && type.type != TokenType::IDENTIFIER) {
                    throw error(type, "Expect a valid type name for parameter.");
            }
            params.emplace_back(mode, name, type);
        } while (match({TokenType::COMMA}));
    }
    consume(TokenType::RPAREN, "Expect ')' after parameter list.");
    return params;
}

void NotalParser::subprogramImplementation(const Token& subprogramKeyword, const Token& subprogramName) {
    auto it = std::find_if(subprogramDeclarations_.begin(), subprogramDeclarations_.end(),
        [&subprogramName](const std::shared_ptr<Statement>& stmt) {
            if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(stmt)) return proc->name.lexeme == subprogramName.lexeme;
            if (auto func = std::dynamic_pointer_cast<FunctionStmt>(stmt)) return func->name.lexeme == subprogramName.lexeme;
            return false;
        });

    if (it == subprogramDeclarations_.end()) {
        throw error(subprogramName, "Implementation provided for an undeclared subprogram.");
    }

    consume(TokenType::LPAREN, "Expect '(' after subprogram name in implementation.");
    std::vector<Parameter> declaredParams;
    if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(*it)) {
        declaredParams = proc->params;
    } else if (auto func = std::dynamic_pointer_cast<FunctionStmt>(*it)) {
        declaredParams = func->params;
    }

    for (size_t i = 0; i < declaredParams.size(); ++i) {
        const auto& param = declaredParams[i];
        if (param.mode == ParameterMode::INPUT) {
            consume(TokenType::INPUT, "Expect 'input' for parameter mode.");
        } else if (param.mode == ParameterMode::OUTPUT) {
            consume(TokenType::OUTPUT, "Expect 'output' for parameter mode.");
        } else if (param.mode == ParameterMode::INPUT_OUTPUT) {
            consume(TokenType::INPUT, "Expect 'input' for parameter mode.");
            consume(TokenType::DIVIDE, "Expect '/' for 'input/output' parameter mode.");
            consume(TokenType::OUTPUT, "Expect 'output' for 'input/output' parameter mode.");
        }
        consume(TokenType::IDENTIFIER, "Expect parameter name.");
        consume(TokenType::COLON, "Expect ':' after parameter name.");
        advance(); 
        if (i < declaredParams.size() - 1) {
            consume(TokenType::COMMA, "Expect ',' between parameters.");
        }
    }
    consume(TokenType::RPAREN, "Expect ')' after parameter list in implementation.");

    if (subprogramKeyword.type == TokenType::FUNCTION) {
        consume(TokenType::ARROW, "Expect '->' for function implementation signature.");
        advance();
    }


    std::shared_ptr<KamusStmt> kamus = nullptr;
    if (check(TokenType::KAMUS)) {
        kamus = this->kamus();
    }

    std::shared_ptr<AlgoritmaStmt> algoritma = this->algoritma();

    if (auto proc = std::dynamic_pointer_cast<ProcedureStmt>(*it)) {
        proc->kamus = kamus;
        proc->body = algoritma;
    } else if (auto func = std::dynamic_pointer_cast<FunctionStmt>(*it)) {
        func->kamus = kamus;
        func->body = algoritma;
    }
}

std::shared_ptr<Statement> NotalParser::returnStatement() {
    Token keyword = consume(TokenType::ARROW, "Expect '->'.");
    std::shared_ptr<Expression> value = expression();
    return std::make_shared<ReturnStmt>(keyword, value);
}


// --- Expression Parsing ---

/**
 * @brief Entry point for expression parsing
 * 
 * Starts the expression parsing chain with assignment expressions
 * (highest precedence in the expression hierarchy).
 * 
 * @return std::shared_ptr<Expression> The expression AST node
 * @throws ParseError if expression syntax is invalid
 */
std::shared_ptr<Expression> NotalParser::expression() {
    return assignment();
}

/**
 * @brief Parses assignment expressions
 * 
 * Handles assignment operations with proper left-hand side validation.
 * 
 * @return std::shared_ptr<Expression> The assignment expression AST node
 * @throws ParseError if assignment target is invalid
 */
std::shared_ptr<Expression> NotalParser::assignment() {
    std::shared_ptr<Expression> expr = logic_or();

    if (match({TokenType::ASSIGN})) {
        Token equals = previous();
        std::shared_ptr<Expression> value = assignment();

        auto unary_expr = std::dynamic_pointer_cast<Unary>(expr);
        if (std::dynamic_pointer_cast<Variable>(expr) ||
            std::dynamic_pointer_cast<FieldAccess>(expr) ||
            std::dynamic_pointer_cast<ArrayAccess>(expr) ||
            (unary_expr && unary_expr->op.type == TokenType::POWER)) {
            return std::make_shared<Assign>(expr, value);
        }

        throw error(equals, "Invalid assignment target.");
    }

    return expr;
}

std::shared_ptr<Expression> NotalParser::logic_or() {
    std::shared_ptr<Expression> expr = logic_and();
    while (match({TokenType::OR, TokenType::XOR})) {
        Token op = previous();
        std::shared_ptr<Expression> right = logic_and();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::logic_and() {
    std::shared_ptr<Expression> expr = equality();
    while (match({TokenType::AND})) {
        Token op = previous();
        std::shared_ptr<Expression> right = equality();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::equality() {
    std::shared_ptr<Expression> expr = comparison();
    while (match({TokenType::NOT_EQUAL, TokenType::EQUAL})) {
        Token op = previous();
        std::shared_ptr<Expression> right = comparison();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::comparison() {
    std::shared_ptr<Expression> expr = term();
    while (match({TokenType::GREATER, TokenType::GREATER_EQUAL, TokenType::LESS, TokenType::LESS_EQUAL})) {
        Token op = previous();
        std::shared_ptr<Expression> right = term();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::term() {
    std::shared_ptr<Expression> expr = factor();
    while (match({TokenType::MINUS, TokenType::PLUS})) {
        Token op = previous();
        std::shared_ptr<Expression> right = factor();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::factor() {
    std::shared_ptr<Expression> expr = power();
    while (match({TokenType::DIVIDE, TokenType::MULTIPLY, TokenType::MOD, TokenType::DIV})) {
        Token op = previous();
        std::shared_ptr<Expression> right = power();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::power() {
    std::shared_ptr<Expression> expr = unary();
    if (match({TokenType::POWER})) {
        Token op = previous();
        std::shared_ptr<Expression> right = power();
        expr = std::make_shared<Binary>(expr, op, right);
    }
    return expr;
}

std::shared_ptr<Expression> NotalParser::unary() {
    if (match({TokenType::NOT, TokenType::MINUS, TokenType::AT})) {
        Token op = previous();
        std::shared_ptr<Expression> right = unary();
        return std::make_shared<Unary>(op, right);
    }
    return call();
}

std::shared_ptr<Expression> NotalParser::call() {
    std::shared_ptr<Expression> expr = primary();
    
    while (true) {
        if (match({TokenType::LPAREN})) {
            expr = finishCall(expr);
        } else if (match({TokenType::LBRACKET})) {
            expr = arrayAccess(expr);
        }
        else if (match({TokenType::DOT})) {
            Token name = consume(TokenType::IDENTIFIER, "Expect field name after '.'.");
            expr = std::make_shared<FieldAccess>(expr, name);
        } else if (check(TokenType::POWER)) {
            Token next = peekNext();
            bool is_binary = (
                next.type == TokenType::IDENTIFIER ||
                next.type == TokenType::INTEGER_LITERAL ||
                next.type == TokenType::REAL_LITERAL ||
                next.type == TokenType::STRING_LITERAL ||
                next.type == TokenType::BOOLEAN_LITERAL ||
                next.type == TokenType::LPAREN ||
                next.type == TokenType::AT ||
                next.type == TokenType::NOT ||
                next.type == TokenType::MINUS
            );

            if (is_binary) {
                break;
            } else {
                Token op = advance();
                expr = std::make_shared<Unary>(op, expr);
            }
        }
        else {
            break;
        }
    }
    
    return expr;
}

std::shared_ptr<Expression> NotalParser::finishCall(std::shared_ptr<Expression> callee) {
    std::vector<std::shared_ptr<Expression>> arguments;
    if (!check(TokenType::RPAREN)) {
        do {
            if (arguments.size() >= 255) {
                error(peek(), "Cannot have more than 255 arguments.");
            }
            arguments.push_back(expression());
        } while (match({TokenType::COMMA}));
    }

    Token paren = consume(TokenType::RPAREN, "Expect ')' after arguments.");

    return std::make_shared<Call>(callee, paren, arguments);
}

std::shared_ptr<Expression> NotalParser::arrayAccess(std::shared_ptr<Expression> callee) {
    std::vector<std::shared_ptr<Expression>> indices;
    indices.push_back(expression());
    Token bracket = consume(TokenType::RBRACKET, "Expect ']' after array index.");

    while(match({TokenType::LBRACKET})) {
        indices.push_back(expression());
        consume(TokenType::RBRACKET, "Expect ']' after array index.");
    }

    return std::make_shared<ArrayAccess>(callee, bracket, indices);
}


std::shared_ptr<Expression> NotalParser::primary() {
    if (match({TokenType::BOOLEAN_LITERAL})) return std::make_shared<Literal>(previous().lexeme == "true");
    if (match({TokenType::INTEGER_LITERAL})) return std::make_shared<Literal>(std::stoi(previous().lexeme));
    if (match({TokenType::REAL_LITERAL})) return std::make_shared<Literal>(std::stod(previous().lexeme));
    if (match({TokenType::STRING_LITERAL})) return std::make_shared<Literal>(previous().lexeme);
    if (match({TokenType::NULL_LITERAL})) return std::make_shared<Literal>(nullptr);
    if (match({TokenType::IDENTIFIER})) return std::make_shared<Variable>(previous());
    if (match({TokenType::LPAREN})) {
        std::shared_ptr<Expression> expr = expression();
        consume(TokenType::RPAREN, "Expect ')' after expression.");
        return std::make_shared<Grouping>(expr);
    }
    throw error(peek(), "Expect expression.");
}

// --- Helper Methods ---

/**
 * @brief Checks if parser has reached end of token stream
 * 
 * @return bool True if at end of file token
 */
bool NotalParser::isAtEnd() { return peek().type == TokenType::END_OF_FILE; }
/**
 * @brief Returns current token without advancing
 * 
 * @return Token The current token
 */
Token NotalParser::peek() { return tokens_[current_]; }
#include "core/ErrorRecovery.h"

Token NotalParser::previous() { return tokens_[current_ - 1]; }

Token NotalParser::advance() {
    if (!isAtEnd()) {
        current_++;
    }
    return previous();
}

bool NotalParser::check(TokenType type) {
    if (isAtEnd()) return false;
    return peek().type == type;
}

bool NotalParser::match(const std::vector<TokenType>& types) {
    for (TokenType type : types) {
        if (check(type)) {
            advance();
            return true;
        }
    }
    return false;
}

Token NotalParser::consume(TokenType type, const std::string& message) {
    if (check(type)) return advance();

    // Attempt phrase-level recovery
    if (PhraseLevelRecovery::tryRecover(this, type)) {
        // Recovery advanced the stream and reported a warning.
        // Return a dummy token of the correct type to allow parsing to continue.
        Token dummy = previous();
        dummy.type = type;
        return dummy;
    }

    throw error(peek(), message);
}

core::Token NotalParser::peekNext() { if (isAtEnd() || current_ + 1 >= tokens_.size()) return peek(); return tokens_[current_ + 1]; }

NotalParser::ParseError NotalParser::error(const Token& token, const std::string& message) {
    diagnostics::SourceLocation loc(token.filename, token.line, token.column, token.lexeme.length());
    diagnosticEngine_.reportSyntaxError(loc, message);
    return ParseError(token, message);
}

void NotalParser::synchronize() {
    PanicModeRecovery::recover(this);
}

} // namespace gate::transpiler
